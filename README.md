# Matix
Little 3D engine test
## Warning
All this README will be in french. Indeed, this project is made for a school project in France.
## Présentation
Matix est un petit moteur de jeu 3D inspiré de Unity fait pour pouvoir créer des jeux comme Doom.
Cependant, il n'utilise pas la technique de ray-cast mais une technique plus récente, OpenGL.
Pour cela, il utilise les lib moderngl, pyglm et pygame, mais aussy numpy.
### Comment fonctionne OpenGL ?
OpenGL est une bibliothèque graphique permettant d'afficher facilement de la 3D (ou 2D) sur un écran. Pour fonctionner, OpenGL utilise un "pipeline graphique", soit une suite d'algorithmes permettant d'afficher quelque chose à l'écran appelés "shaders", tournant sur GPU. Il faut lui donner une suite de points formants une suite de triangles. OpenGL va (en gros) calculer les points, puis calculer les connexions, puis calculer les pixels de chaques triangles (appelé fragment), puis d'afficher le tout. Dans ce pipeline, il y a 2 shaders modifiables : le shader de point et le shader de fragment. Le premier permet de calculer la position précise des points et le deuxième la couleur de fragments du triangle. Pour cela, il faut passer les points dans la mémoire du GPU avec ce qu'on appelle un VBO (vertex buffer object). Le shader est lui modifié à l'aide d'un programme de shader. Le tout est traité dans ce qu'on appelle un VAO (vertex array object). Il s'occupera de l'affichage.
### Comment fonctionne ModernGL et PyGlm ?
Ces 2 librairies Python permettent d'utiliser OpenGL avec Python. ModernGL permet d'accéder directement à OpenGL et PyGLM offre des moyens d'y accéder plus facilement. Pygame permet de faciliter un peu plus l'accés. Pour commencer, il faut créer un contexte OpenGL, en sachant que Pygame le fait automatiquement avec la fonction init(). On peut le récuperer grâce à ModernGL et accéder au à OpenGL. Avec ce contexte, on peut créer un programme de shader, des VBOs et VAOs sans difficultés. De plus, avec Pygame, on peut définir quelques paramètre OpenGL facilement.
### Comment est structuré le moteur de jeu ?
Le moteur de jeu est découpé en beaucoup de fichiers, pour simplifier l'accés aux fonctionnalités. Le fichier main.py permet de lancer le jeu et de modifier facilement le jeu. Le fichier game.py permet de stocker la classe permettant l'accés au jeu. Le fichier scene.py permet de stocker tout ce qui est à propos des scènes. Le fichier base_struct.py permet de définir une classe contenant des variables/classes globals et de les utiliser facilement. C'est pareil pour advanced_struct, mais avec des variables plus avancées. Le fichier player.py contient tout ce qui permet l'utilisation du joueur et le fichier model.py contient l'utilisation des VBO, VAO, programmes de shaders, textures et modèles simples. Le dossier map contient les maps pour le jeu, shaders les shaders du jeu et textures les différents textures du jeu.
## Fonctionnement
Matix est grandement inspiré de Unity, rendant son fonctionnement assez simple.
### Comment afficher de la 3D ?
Matix utilise plusieurs la classes dans model.py permettant d'afficher de la 3D. "Shader_Program" permet de charger un shader. Pour cela, il prend en entré un chemin d'accés, auquelle il va rajouter ".vert" et ".frag" pour accéder aux shaders. Les fichiers finissant en ".frag" et ".vert" sont des fichiers en GLSL, le langage de programmation des shaders (similaire à C). Il sont chargés grâce à une classe de ModernGL. Pour fonctionner, il y a aussi besoin des VBOs. Chaques VBO héritents de la classe "VBO". Entre chaques classes de VBOs, 3 choses changent : la valeur de "format", la valeur de "attributes" et la méthode "get_vertex_data". Le format représente le type de chaques variables "in" du shaders ".vert" et "attributes" le nom complet de ces variables. VBO va ensuite charger le retour de "get_vertex_data" dans le GPU pour utilisation. Pour fonctionner correctement, "get_vertex_data" doit retourner une liste numpy contenant les données dans le même ordre que dans "attributes" et avec les mêmes types. La classe "VAO" réunit un "Shader_Program" et un "VBO" pour permettre de faire un rendu grâce à "render()". La classe "Graphic_Object" permet de gérer tout ça facilement, et est utilisé par les autres classes pour afficher un objet sur l'écran. Certains objets nécessitant un rendu un peu particulier comme "Cube_Object" sont implémentés hors de "Graphic_Object". Pour permettre un affichage plus complet, la classe "Camera" de player.py et "Transform_Object" et "Camera_Value" de base_struct.py sont utilisées. Les shaders permettent aussi d'utiliser des textures, qui sont chargées grâce à "Texture" dans model.py. Les plans prennent une texture, mais les cubes en prennent 6, une par face (4 étant la face basse, 5 la face haute, et les autres celles du côté). La texture peut être une image .PNG, .JPG, .JPEG, ou un dossier pour les cubes, contenant 6 textures, du même nom que leur face respective.
### Comment gérer de la 3D ?
Chaque objet représente un ensemble de point connecté pour faire un objet en 3D. L'utilisation de "Transform_Object", dont hérite tous les objets graphiques permet de leur appliquer des modifications géométrique (mouvement, rotation ou taille). Ce système permet aussi de créer une hiérarchie d'objet pour mieux structurer le tout. Chaque objets a un nom et appartient à une scène de classe "Scene" dans scene.py, qui est aussi un objet "Transform_Object". Chaque scène à aussi un nom et sont stockées dans "Game" de game.py.